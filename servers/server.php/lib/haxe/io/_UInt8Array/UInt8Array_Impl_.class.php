<?php

// Generated by Haxe 3.4.2 (git build master @ 890f8c7)
class haxe_io__UInt8Array_UInt8Array_Impl_ {
	public function __construct(){}
	static $BYTES_PER_ELEMENT = 1;
	static function _new($elements) {
		$this1 = null;
		$this2 = new haxe_io_ArrayBufferViewImpl(haxe_io_Bytes::alloc($elements), 0, $elements);
		$this1 = $this2;
		return $this1;
	}
	static function get_length($this1) {
		return $this1->byteLength;
	}
	static function get_view($this1) {
		return $this1;
	}
	static function get($this1, $index) {
		$pos = $index + $this1->byteOffset;
		$this2 = $this1->bytes->b;
		return ord($this2->s[$pos]);
	}
	static function set($this1, $index, $value) {
		$tmp = null;
		if($index >= 0) {
			$tmp = $index < $this1->byteLength;
		} else {
			$tmp = false;
		}
		if($tmp) {
			{
				$pos = $index + $this1->byteOffset;
				{
					$this2 = $this1->bytes->b;
					$this2->s[$pos] = chr($value);
				}
			}
			return $value;
		}
		return 0;
	}
	static function sub($this1, $begin, $length = null) {
		return haxe_io__UInt8Array_UInt8Array_Impl_::fromData($this1->sub($begin, $length));
	}
	static function subarray($this1, $begin = null, $end = null) {
		return haxe_io__UInt8Array_UInt8Array_Impl_::fromData($this1->subarray($begin, $end));
	}
	static function getData($this1) {
		return $this1;
	}
	static function fromData($d) {
		return $d;
	}
	static function fromArray($a, $pos = null, $length = null) {
		if($pos === null) {
			$pos = 0;
		}
		if($length === null) {
			$length = $a->length - $pos;
		}
		$tmp = null;
		$tmp1 = null;
		if($pos >= 0) {
			$tmp1 = $length < 0;
		} else {
			$tmp1 = true;
		}
		if(!$tmp1) {
			$tmp = $pos + $length > $a->length;
		} else {
			$tmp = true;
		}
		if($tmp) {
			throw new HException(haxe_io_Error::$OutsideBounds);
		}
		$elements = $a->length;
		$this1 = null;
		$this2 = new haxe_io_ArrayBufferViewImpl(haxe_io_Bytes::alloc($elements), 0, $elements);
		$this1 = $this2;
		$i = $this1;
		{
			$_g1 = 0;
			$_g = $length;
			while($_g1 < $_g) {
				$_g1 = $_g1 + 1;
				$idx = $_g1 - 1;
				{
					$value = $a[$idx + $pos];
					$tmp2 = null;
					if($idx >= 0) {
						$tmp2 = $idx < $i->byteLength;
					} else {
						$tmp2 = false;
					}
					if($tmp2) {
						$pos1 = $idx + $i->byteOffset;
						{
							$this3 = $i->bytes->b;
							$this3->s[$pos1] = chr($value);
							unset($this3);
						}
						unset($pos1);
					}
					unset($value,$tmp2);
				}
				unset($idx);
			}
		}
		return $i;
	}
	static function fromBytes($bytes, $bytePos = null, $length = null) {
		if($bytePos === null) {
			$bytePos = 0;
		}
		return haxe_io__UInt8Array_UInt8Array_Impl_::fromData(haxe_io__ArrayBufferView_ArrayBufferView_Impl_::fromBytes($bytes, $bytePos, $length));
	}
	static $__properties__ = array("get_view" => "get_view","get_length" => "get_length");
	function __toString() { return 'haxe.io._UInt8Array.UInt8Array_Impl_'; }
}
