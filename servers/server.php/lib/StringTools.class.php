<?php

// Generated by Haxe 3.4.2 (git build master @ 890f8c7)
class StringTools {
	public function __construct(){}
	static function urlEncode($s) {
		return rawurlencode($s);
	}
	static function urlDecode($s) {
		return urldecode($s);
	}
	static function htmlEscape($s, $quotes = null) {
		$s = _hx_explode(">", _hx_explode("<", _hx_explode("&", $s)->join("&amp;"))->join("&lt;"))->join("&gt;");
		if($quotes) {
			return _hx_explode("'", _hx_explode("\"", $s)->join("&quot;"))->join("&#039;");
		} else {
			return $s;
		}
	}
	static function htmlUnescape($s) {
		return htmlspecialchars_decode($s, ENT_QUOTES);
	}
	static function startsWith($s, $start) {
		if(strlen($s) >= strlen($start)) {
			return _hx_substr($s, 0, strlen($start)) === $start;
		} else {
			return false;
		}
	}
	static function endsWith($s, $end) {
		$elen = strlen($end);
		$slen = strlen($s);
		if($slen >= $elen) {
			return _hx_substr($s, $slen - $elen, $elen) === $end;
		} else {
			return false;
		}
	}
	static function isSpace($s, $pos) {
		$c = _hx_char_code_at($s, $pos);
		$tmp = null;
		if($c >= 9) {
			$tmp = $c <= 13;
		} else {
			$tmp = false;
		}
		if(!$tmp) {
			return $c === 32;
		} else {
			return true;
		}
	}
	static function ltrim($s) {
		return ltrim($s);
	}
	static function rtrim($s) {
		return rtrim($s);
	}
	static function trim($s) {
		return trim($s);
	}
	static function rpad($s, $c, $l) {
		$tmp = null;
		if(strlen($c) !== 0) {
			$tmp = strlen($s) >= $l;
		} else {
			$tmp = true;
		}
		if($tmp) {
			return $s;
		} else {
			return str_pad($s, Math::ceil(($l - strlen($s)) / strlen($c)) * strlen($c) + strlen($s), $c, STR_PAD_RIGHT);
		}
	}
	static function lpad($s, $c, $l) {
		$tmp = null;
		if(strlen($c) !== 0) {
			$tmp = strlen($s) >= $l;
		} else {
			$tmp = true;
		}
		if($tmp) {
			return $s;
		} else {
			return str_pad($s, Math::ceil(($l - strlen($s)) / strlen($c)) * strlen($c) + strlen($s), $c, STR_PAD_LEFT);
		}
	}
	static function replace($s, $sub, $by) {
		if($sub === "") {
			return implode(str_split ($s), $by);
		} else {
			return str_replace($sub, $by, $s);
		}
	}
	static function hex($n, $digits = null) {
		$s = dechex($n);
		$len = 8;
		$tmp = null;
		if(null === $digits) {
			$tmp = $len;
		} else {
			if($digits > $len) {
				$len = $digits;
			} else {
				$len = $len;
			}
			$tmp = $len;
		}
		if(strlen($s) > $tmp) {
			$s = _hx_substr($s, -$len, null);
		} else {
			if($digits !== null) {
				$s1 = null;
				if(strlen("0") !== 0) {
					$s1 = strlen($s) >= $digits;
				} else {
					$s1 = true;
				}
				if($s1) {
					$s = $s;
				} else {
					$s = str_pad($s, Math::ceil(($digits - strlen($s)) / strlen("0")) * strlen("0") + strlen($s), "0", STR_PAD_LEFT);
				}
			}
		}
		return strtoupper($s);
	}
	static function fastCodeAt($s, $index) {
		return ord(substr($s,$index,1));
	}
	static function isEof($c) {
		return ($c === 0);
	}
	static function quoteUnixArg($argument) {
		if($argument === "") {
			return "''";
		}
		$tmp = !_hx_deref(new EReg("[^a-zA-Z0-9_@%+=:,./-]", ""))->match($argument);
		if($tmp) {
			return $argument;
		}
		return "'" . _hx_string_or_null(str_replace("'", "'\"'\"'", $argument)) . "'";
	}
	static $winMetaCharacters;
	static function quoteWinArg($argument, $escapeMetaCharacters) {
		$tmp = !_hx_deref(new EReg("^[^ \x09\\\\\"]+\$", ""))->match($argument);
		if($tmp) {
			$result = new StringBuf();
			$needquote = null;
			$needquote1 = null;
			if(_hx_index_of($argument, " ", null) === -1) {
				$needquote1 = _hx_index_of($argument, "\x09", null) !== -1;
			} else {
				$needquote1 = true;
			}
			if(!$needquote1) {
				$needquote = $argument === "";
			} else {
				$needquote = true;
			}
			if($needquote) {
				$result->add("\"");
			}
			$bs_buf = new StringBuf();
			{
				$_g1 = 0;
				$_g = strlen($argument);
				while($_g1 < $_g) {
					$_g1 = $_g1 + 1;
					$i = $_g1 - 1;
					{
						$_g2 = _hx_char_code_at($argument, $i);
						if($_g2 === null) {
							$c = $_g2;
							{
								if(strlen($bs_buf->b) > 0) {
									$result->add($bs_buf->b);
									$bs_buf = new StringBuf();
								}
								$result1 = $result;
								$result1->b = _hx_string_or_null($result1->b) . _hx_string_or_null(chr($c));
								unset($result1);
							}
							unset($c);
						} else {
							switch($_g2) {
							case 34:{
								$bs = $bs_buf->b;
								$result->add($bs);
								$result->add($bs);
								$bs_buf = new StringBuf();
								$result->add("\\\"");
							}break;
							case 92:{
								$bs_buf->add("\\");
							}break;
							default:{
								$c1 = $_g2;
								{
									if(strlen($bs_buf->b) > 0) {
										$result->add($bs_buf->b);
										$bs_buf = new StringBuf();
									}
									$result2 = $result;
									$result2->b = _hx_string_or_null($result2->b) . _hx_string_or_null(chr($c1));
								}
							}break;
							}
						}
						unset($_g2);
					}
					unset($i);
				}
			}
			$result->add($bs_buf->b);
			if($needquote) {
				$result->add($bs_buf->b);
				$result->add("\"");
			}
			$argument = $result->b;
		}
		if($escapeMetaCharacters) {
			$result3 = new StringBuf();
			{
				$_g11 = 0;
				$_g3 = strlen($argument);
				while($_g11 < $_g3) {
					$_g11 = $_g11 + 1;
					$i1 = $_g11 - 1;
					$c2 = _hx_char_code_at($argument, $i1);
					if(StringTools::$winMetaCharacters->indexOf($c2, null) >= 0) {
						$result4 = $result3;
						$result4->b = _hx_string_or_null($result4->b) . "^";
						unset($result4);
					}
					$result5 = $result3;
					$result5->b = _hx_string_or_null($result5->b) . _hx_string_or_null(chr($c2));
					unset($result5,$i1,$c2);
				}
			}
			return $result3->b;
		} else {
			return $argument;
		}
	}
	function __toString() { return 'StringTools'; }
}
StringTools::$winMetaCharacters = (new _hx_array(array(59, 44, 32, 40, 41, 37, 33, 94, 34, 60, 62, 38, 124, 10, 13)));
